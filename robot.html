<!DOCTYPE html>
<html>

<head>
    <title>Trabalho 2 -- Alternative BDSF</title>
    <meta charset="utf-8">
    <!-- libraries -->
    <!--link rel="stylesheet" href="/common/lib/normalize.css"-->
    <script type="text/javascript" src="/common/lib/gl-matrix.js"></script>
    <script type="text/javascript" src="/common/lib/dat.gui.js"></script>

    <!-- modules -->
    <script type="text/javascript" src="/common/js/utils.js"></script>
    <script type="text/javascript" src="/common/js/Program.js"></script>

    <link rel="shortcut icon" href="#">

    <script id="vertex-shader" type="x-shader/x-vertex">
            #version 300 es
            precision highp float;
            precision highp int;
            
            uniform vec3 uLightPosition;
            uniform vec3 uLightAmbient;
            uniform vec3 uMaterialDiffuse;
            uniform vec3 uEyePosition;

            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            uniform mat4 uNormalMatrix;
            uniform vec4 uLightDiffuse;
            uniform vec4 uLightSpecular;
            
            uniform highp int uTextureActive;
            uniform highp int uShaderSelection;

            uniform highp float uShininess;
        
            in vec3 aVertexPosition;
            in vec3 aVertexNormal;
            in vec3 aVertexColor;
            in vec2 aVertexTextureCoords;
        
            out vec4 fragPos;
            out vec4 vColor;
            out vec4 vNormal;
            out vec3 vLightRay;
            out vec3 vEyeVector;
            out vec2 vTextureCoords;

            void vertex_ward(void){
                gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);
                vNormal = vec4(uNormalMatrix * vec4(aVertexNormal, 1.0));
                fragPos = uModelViewMatrix * vec4(aVertexPosition, 1.0);

                vLightRay = uLightPosition - vec3(fragPos);

                vEyeVector = -(vec3(uModelViewMatrix) * aVertexPosition);
            }

            void vertex_cook_torrance(void){

                vNormal = vec4(uNormalMatrix * vec4(aVertexNormal, 1.0));

                fragPos = uModelViewMatrix * vec4(aVertexPosition, 1.0);

                vLightRay = uLightPosition - vec3(fragPos);

                vEyeVector = -(vec3(uModelViewMatrix) * aVertexPosition);

                gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);
            }

            void vertex_gouraud(void){
                vec3 normal = vec3(uNormalMatrix * vec4(aVertexNormal, 1.0));
                vec3 normalizedLightPosition = normalize(-uLightPosition);

                float lambertTerm = dot(normal, -normalizedLightPosition);

                vec4 Iambient = vec4(uLightAmbient, 1.0);
                vec4 Idiffuse = vec4(0.0, 0.0, 0.0, 1.0);
                vec4 Ispecular = vec4(0.0, 0.0, 0.0, 1.0);

                if(lambertTerm > 0.0){
                    vec3 reflecc = reflect(normalizedLightPosition, normal);
                    vec3 view = normalize(-uEyePosition);
                    float specularTerm = pow( max( dot(reflecc, view), 0.0), uShininess);
                    Idiffuse = vec4(uMaterialDiffuse, 1.0) * lambertTerm;
                    Ispecular = uLightSpecular * specularTerm;
                }
                vColor = vec4(vec3(Iambient+Idiffuse+Ispecular), 1.0);

                gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);

                if(uTextureActive == 1){
                    vTextureCoords = aVertexTextureCoords;
                }
            }

            void vertex_phong(void){
                vec4 vertex = uModelViewMatrix * vec4(aVertexPosition, 1.0);
                vNormal = vec4(uNormalMatrix * vec4(aVertexNormal, 1.0));
                gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);
                fragPos = uModelViewMatrix * vec4(aVertexPosition, 1.0);
                if(uTextureActive == 1){
                    vTextureCoords = aVertexTextureCoords;
                }
            }
        
            void vertex_lambert(void){
                vec4 vertex = uModelViewMatrix * vec4(aVertexPosition, 1.0);
                vec4 light = vec4(uLightPosition,1.0);
            
                // Set varyings to be used in fragment shader
                vNormal = vec4(uNormalMatrix * vec4(aVertexNormal, 1.0));
                vLightRay = vertex.xyz - light.xyz;
                vEyeVector = -vec3(vertex.xyz);
            
                gl_Position = uProjectionMatrix * vertex;
            }

            void main(void){
                if(uShaderSelection == 0){
                    vertex_lambert();
                } else if (uShaderSelection == 1){
                    vertex_gouraud();
                } else if(uShaderSelection == 2){
                    vertex_cook_torrance();
                } else if(uShaderSelection == 3){
                    vertex_ward();
                }else {
                    vertex_phong();
                }
            }
        </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
            #version 300 es

            #define PI 3.1415926538

            precision highp float;
            precision highp int;

            uniform vec3 uLightPosition;
            uniform vec3 uLightAmbient;
            uniform vec3 uMaterialDiffuse;
            uniform vec3 uMaterialSpecular;
            uniform vec3 uEyePosition;

            uniform mat4 uNormalMatrix;
            uniform vec4 uLightDiffuse;
            uniform vec4 uLightSpecular;

            uniform highp int uTextureActive;
            uniform highp int uShaderSelection;

            uniform highp float uShininess;
            uniform highp float uRoughness; //used in Cook-Torrance shader
            uniform highp float uDiffuse; //ye olde uDiffuse, used in Cook-Torrance shader
            uniform highp float uReflectance; //ye olde uReflectance, used for Fresnel in Cook-Torrance]
            uniform highp float uDiffuseWard; //used in Ward shader
            uniform highp float uLobeMagnitude; //used in Ward shader
            uniform highp float uAlphaX;
            uniform highp float uAlphaY;

            uniform sampler2D uSampler;
        
            in vec4 vColor;
            in vec4 fragPos;
            in vec4 vNormal;
            in vec3 vLightRay;
            in vec3 vEyeVector;
            in vec2 vTextureCoords;
        
            out vec4 fragColor;

            void frag_ward(void){
                vec3 lightDir = normalize(vLightRay);
                vec3 normal = normalize(vec3(vNormal));
                vec3 normalizedLightPosition = normalize(fragPos.xyz - uLightPosition);

                float NdotL = dot(normal, lightDir);

                //Diffuse term
                float diffuseTerm = uDiffuseWard/PI;

                //Specular term, auxiliary stuff
                vec3 halfVector = normalize(-lightDir + normalize(vEyeVector));
                float HdotX = max(dot(halfVector, /*vec3(1.0, 0.0, 0.0) * */normal), 0.0); //X is the X axis
                float HdotY = max(dot(halfVector, /*vec3(0.0, 1.0, 0.0) * */normal), 0.0); //Y is the Y axis
                float HdotN = max(dot(halfVector, normal), 0.0);
                float IdotN = max(dot(vEyeVector, normal), 0.0);
                float OdotN = max(dot(normalizedLightPosition, normal), 0.0);

                //Specular term
                float expoent = (((HdotX/uAlphaX) * (HdotX/uAlphaX)) + ((HdotY/uAlphaY) * (HdotY/uAlphaY)))/(HdotN * HdotN);
                float denominator = 4.0 * PI * uAlphaX * uAlphaY * sqrt(IdotN * OdotN);
                float specularTerm = (uLobeMagnitude/denominator) * exp(-expoent);

                //set the frag color
                fragColor = /*vec4(uLightAmbient, 1.0) +*/ (diffuseTerm + specularTerm)*vec4(vec3(vec4(normal, 1.0) * vColor), 1.0);
            }

            void frag_cook_torrance(void){
                vec3 lightDir = normalize(vLightRay);
                vec3 normal = vec3(vNormal);

                float NdotL = dot(normal, lightDir); //N for Normal, L for Light Direction

                float specularTerm = 0.0;
                if(NdotL > 0.0){
                    vec3 halfVector = normalize(lightDir + normalize(vEyeVector));
                    float NdotH = max(dot(normal, halfVector), 0.0); //N for normal, H for Half Vector
                    float NdotV = max(dot(normal, vEyeVector), 0.0); //N for normal, V for Eye Vector
                    float VdotH = max(dot(vEyeVector, halfVector), 0.0); //V for Eye Vector, H for Half Vector
                    float NdotM = max(dot(normal, normal), 0.0); //N for normal, M for microfacets normals
                    float mSquare = uRoughness * uRoughness;

                    //geometric attenuation following Cook-Torrance formula
                    float second = (2.0 * NdotV * NdotM)/VdotH; float third = (2.0 * NdotM * NdotL)/VdotH;
                    float geoAtt = max(second, third); geoAtt = max(geoAtt, 1.0);

                    //Microfacet distribution function using Beckmann's distribution
                    float r1 = 1.0/(PI * mSquare * pow(NdotH, 4.0));
                    float r2 = (NdotH * NdotH - 1.0)/(mSquare * NdotH * NdotH);
                    float roughness = r1 * exp(r2);

                    //Fresnel using Schlick's approximation
                    float fresnel = pow(1.0 - VdotH, 5.0);
                    fresnel *= (1.0 - uReflectance);
                    fresnel += uReflectance;

                    specularTerm = (fresnel * geoAtt * roughness)/(NdotV * NdotL * PI);
                }
                vec3 finalValue = /*uLightAmbient + */vec3(vColor) + NdotL * ((uDiffuse * vec3(0.0, 0.0, 0.0)) + (vec3(0.75, 0.75, 0.75)*specularTerm*(1.0 - uDiffuse)));
                fragColor = vec4(finalValue, 1.0);
                
            }

            void frag_gouraud(void){
                vec4 color;
                if(uTextureActive == 1){
                    color = vColor * texture(uSampler, vTextureCoords);
                } else {
                    color = vColor;
                }
                fragColor = color;
            }

            void frag_phong(void){
                vec4 color;
                vec3 normal = vNormal.xyz;
                vec3 pos = fragPos.xyz;
                vec3 normalizedLightPosition = normalize(pos-uLightPosition);

                float lambertTerm = dot(normal, -normalizedLightPosition);

                vec4 Iambient = vec4(uLightAmbient, 1.0);
                vec4 Idiffuse = vec4(0.0, 0.0, 0.0, 1.0);
                vec4 Ispecular = vec4(0.0, 0.0, 0.0, 1.0);

                if(lambertTerm > 0.0){
                    vec3 reflecc = reflect(normalizedLightPosition, normal);
                    vec3 view = normalize(-uEyePosition);
                    float specularTerm = pow( max( dot(reflecc, view), 0.0), uShininess);

                    Idiffuse = vec4(uMaterialDiffuse, 1.0) * lambertTerm;
                    Ispecular = vec4(uMaterialSpecular, 1.0) * uLightSpecular * specularTerm;
                }
                color = vColor + vec4(vec3(Iambient + Idiffuse + Ispecular), 1.0);
                if(uTextureActive == 1){
                    color = color * texture(uSampler, vTextureCoords);
                }
                fragColor = color;
            }
        
            void frag_lambert(void) {
              vec3 L = normalize(vLightRay);
              vec3 N = normalize(vNormal.xyz);
              float lambertTerm = dot(N, -L);
              vec3 finalColor = uLightAmbient;
        
              if (lambertTerm > 0.0) {
                finalColor += uMaterialDiffuse * lambertTerm;
                vec3 E = normalize(vEyeVector);
                vec3 R = reflect(L, N);
                float specular = pow( max(dot(R, E), 0.0), uShininess);
                finalColor += uMaterialSpecular * specular;
              }
        
              fragColor = vec4(finalColor, 1.0);
            }

            void main(void){
                if(uShaderSelection == 0){
                    frag_lambert();
                } else if (uShaderSelection == 1){
                    frag_gouraud();
                } else if (uShaderSelection == 2){
                    frag_cook_torrance();
                } else if (uShaderSelection == 3){
                    frag_ward();
                }else {
                    frag_phong();
                }
            }
        </script>


    <script type="text/javascript">
        'use strict';

        //Global variables
        let
            gl,
            program,
            robot = [],
            before = 0,
            shininess = 16,
            textureActive = 0,
            shaderSelection = 3,
            normalMatrix = mat4.create(),
            clearColor = [0.2, 0.2, 0.35],
            lightPosition = [-0, 50, 0],
            modelViewMatrix = mat4.create(),
            projectionMatrix = mat4.create(),
            xAngle = 25.0, yAngle = 0.0, zAngle = -0.0,
            zDistance = -20, yDistance = 0, xDistance = 0,
            transformPosition = [xDistance, yDistance, zDistance],
            zRot = zAngle * Math.PI / 180, yRot = yAngle * Math.PI / 180, xRot = xAngle * Math.PI / 180,
            transformRotate = [xRot, yRot, zRot],
            diffuse = 0.2, reflectance = 0.8, roughness = 0.2,
            materialDiffuse = 1.0, materialSpecular = 1.0,
            lightDiffuse = 1.0, lightSpecular = 0.6, lightAmbient = 0.2,
            diffuseWard = 0.2, lobe = 0.7, alphaX = 0.8, alphaY = 0.8;

        async function getShader(type, path) {
            let shaderSource;

            await fetch(path).then(
                resp => resp.text()
            ).then(
                (result) => {
                    shaderSource = result;
                }
            ).catch(err => console.log(err));

            let shader;
            if (type === 'vertex') {
                shader = gl.createShader(gl.VERTEX_SHADER);
            } else if (type === 'fragment') {
                shader = gl.createShader(gl.FRAGMENT_SHADER);
            } else {
                return null;
            }

            gl.shaderSource(shader, shaderSource);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                return null;
            }

            return shader;
        }

        async function getModel(path) {
            let model;

            await fetch(path).then(
                resp => resp.json()
            ).then(
                (result) => {
                    model = result;
                }
            ).catch(err => console.log(err));

            return model;
        }

        // Global variables to use throughout application
        async function initProgram() {
            const canvas = document.getElementById('webgl-canvas');

            gl = canvas.getContext('webgl2') || console.error('WebGL2 is not available in your browser.');
            gl.clearColor(...clearColor, 1);
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);

            program = new Program(gl, 'vertex-shader', 'fragment-shader');

            //let vertexShader = /*gl.createShader(gl.VERTEX_SHADER), rawVertexShaderSrc = document.getElementById('vertex-shader'); let vertexShaderSrc = rawVertexShaderSrc.text.trim(); gl.shaderSource(vertexShader, vertexShaderSrc); gl.compileShader(vertexShader);*/ await getShader('vertex', 'robot_vertex.glsl');
            //let fragShader = /*gl.createShader(gl.FRAGMENT_SHADER), rawFragShaderSrc = document.getElementById('fragment-shader'); let fragShaderSrc = rawFragShaderSrc.text.trim(); gl.shaderSource(fragShader, fragShaderSrc); gl.compileShader(fragShader);*/ await getShader('fragment', 'robot_frag.glsl');

            //gl.attachShader(program, vertexShader);
            //gl.attachShader(program, fragShader);
            ///gl.linkProgram(program);

            //gl.useProgram(program);

            /*if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                return console.error('Could not initialize shaders.');
            }*/

            // Attributes to be loaded into program
            const attributes = [
                'aVertexPosition',
                'aVertexNormal',
                'aVertexColor',
                'aVertexTextureCoords',
            ];

            // Uniforms to be loaded into program
            const uniforms = [
                'uProjectionMatrix',
                'uModelViewMatrix',
                'uNormalMatrix',
                'uLightAmbient',
                'uLightDiffuse',
                'uLightSpecular',
                'uLightPosition',
                'uTextureActive',
                'uMaterialSpecular',
                'uMaterialDiffuse',
                'uEyePosition',
                'uShininess',
                'uSampler',
                'uShaderSelection',
                'uRoughness',
                'uDiffuse',
                'uReflectance',
                'uDiffuseWard',
                'uLobeMagnitude',
                'uAlphaX', 'uAlphaY'
            ];
            program.load(attributes, uniforms);
            gl.uniform1i(program.uTextureActive, textureActive);
        }

        function initLights() {

            gl.uniform3fv(program.uLightPosition, lightPosition);
            gl.uniform3f(program.uLightAmbient, lightAmbient, lightAmbient, lightAmbient);
            gl.uniform3f(program.uLightSpecular, lightSpecular, lightSpecular, lightSpecular);
            gl.uniform3f(program.uLightDiffuse, lightDiffuse, lightDiffuse, lightDiffuse);
            gl.uniform3f(program.uMaterialSpecular, materialSpecular, materialSpecular, materialSpecular);
            gl.uniform3f(program.uMaterialDiffuse, materialDiffuse, materialDiffuse, materialDiffuse);
            gl.uniform1f(program.uShininess, shininess);
            gl.uniform1f(program.uRoughness, roughness);
            gl.uniform1f(program.uDiffuse, diffuse);
            gl.uniform1f(program.uReflectance, reflectance);
            gl.uniform1f(program.uDiffuseWard, diffuseWard);
            gl.uniform1f(program.uLobeMagnitude, lobe);
            gl.uniform1f(program.uAlphaX, alphaX);
            gl.uniform1f(program.uAlphaY, alphaY);
        }

        function initControls() {
            var axis = ["x", "y", "z"];

            utils.configureControls(
                {
                    LightsControl:{
                        Position:{
                            ...['lightPosition X', 'lightPosition Y', 'lightPosition Z'].reduce((result, name, i) => {
                                result[name] = {
                                    value: lightPosition[i],
                                    min: -300, max: 300, step: 0.00001, onChange(v, state){
                                        lightPosition[i] = v;
                                    }
                                };
                                return result;
                            }, {}),
                        },
                    },
                    Shader:{
                        'Shader Selection': {
                            value: "Cook-Torrance", options: ["Lambert", "Gouraud", "Phong", "Cook-Torrance", "Ward"],
                            onChange: v => {
                                if(v == "Lambert"){
                                    shaderSelection = 0;
                                } else if (v == "Gouraud"){
                                    shaderSelection = 1;
                                } else if (v == "Cook-Torrance") {
                                    shaderSelection = 2;
                                } else if (v == "Ward"){
                                    shaderSelection = 3;
                                } else {
                                    shaderSelection = -1;
                                }
                            }
                        },
                        'General Settings (for Lambert, Phong and Gouraud)':{
                            'Shininess':{
                                value: shininess, min: 0, max: 5, step: 0.00001, onChange(v, state){shininess = v;}
                            },
                            'Material Diffuse': {
                                value: materialDiffuse, min: 0.00001, max: 5, step: 0.00001, onChange(v, state){materialDiffuse = v;}
                            },
                            'Material Specular':{
                                value: materialSpecular, min: 0.00001, max: 5, step: 0.00001, onChange(v, state){materialSpecular = v;}
                            },
                            'Light Ambient':{
                                value: lightAmbient, min: 0.00001, max: 5, step: 0.00001, onChange(v, state){lightAmbient = v;}
                            },
                            'Light Diffuse':{
                                value: lightDiffuse, min: 0.00001, max: 5, step: 0.00001, onChange(v, state){lightDiffuse = v;}
                            },
                            'Light Specular':{
                                value: lightSpecular, min: 0.00001, max: 5, step: 0.00001, onChange(v, state){lightSpecular = v;}
                            },
                        },
                        'Cook-Torrance Settings': {
                            'Roughness':{
                                value: roughness, min: 0.00000001, max: 0.99999999, step: 0.00001, onChange(v, state){roughness = v;}
                            },
                            'Diffuse':{
                                value: diffuse, min: 0.00000001, max: 0.99, step: 0.00001, onChange(v, state){diffuse = v;}
                            },
                            'Reflectance':{
                                value: reflectance, min: 0.00000001, max: 1, step: 0.00001, onChange(v, state){reflectance = v;}
                            }
                        },
                        'Ward Settings': {
                            'Diffuse':{
                                value: diffuseWard, min: 0.00000001, max: 0.99999999, step: 0.00001, onChange(v, state){diffuseWard = v;}
                            },
                            'Lobe Magnitude':{
                                value: lobe, min: 0.00000001, max: 0.99999999, step: 0.00001, onChange(v, state){lobe = v;}
                            },
                            'Alpha X':{
                                value: alphaX, min: 0.00000001, max: 0.99999999, step: 0.00001, onChange(v, state){alphaX = v;}
                            },
                            'Alpha Y':{
                                value: alphaY, min: 0.00000001, max: 0.99999999, step: 0.00001, onChange(v, state){alphaY = v;}
                            }
                        }
                    },
                    SceneControl:{
                        ...['Translate X', 'Translate Y', 'Translate Z'].reduce((result, name, i) => {
                            result[name] = {
                                value: transformPosition[i],
                                min: -50, max: 50, step: 0.00001, onChange(v, state){
                                    transformPosition[i] = v;
                                }
                            };
                            return result;
                        }, {}),
                        ...['Rotate X', 'Rotate Y', 'Rotate Z'].reduce((result, name, i) => {
                            result[name] = {
                                value: transformRotate[i],
                                min: -180, max: 180, step: 0.00001,
                                onChange(v, state){
                                    transformRotate = [
                                        state['Rotate X']*Math.PI/180,
                                        state['Rotate Y']*Math.PI/180,
                                        state['Rotate Z']*Math.PI/180
                                    ];
                                }
                            };
                            return result;
                        }, {})
                    }
                }
            );
        }

        function animate() {
            const now = new Date().getTime();
            if (before) {
                const elapsed = now - before;
                yRot += (Math.PI * elapsed) / 2500;
            }
            before = now;
        }

        function render() {
            requestAnimationFrame(render);
            draw();
            animate();
        }

        function load() {
            fetch('Robot_2.json').then(resp => resp.json()).then(robotJson => {
                // Configure VAO
                const vao = gl.createVertexArray();
                gl.bindVertexArray(vao);

                // Vertices
                const vertexBufferObject = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBufferObject);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(robotJson.vertices), gl.STATIC_DRAW);
                // Configure instructions for VAO
                gl.enableVertexAttribArray(program.aVertexPosition);
                gl.vertexAttribPointer(program.aVertexPosition, 3, gl.FLOAT, false, 0, 0);

                // Normals
                const normalBufferObject = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, normalBufferObject);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(robotJson.normals), gl.STATIC_DRAW);
                // Configure instructions for VAO
                gl.enableVertexAttribArray(program.aVertexNormal);
                gl.vertexAttribPointer(program.aVertexNormal, 3, gl.FLOAT, false, 0, 0);

                // Indices
                const indexBufferObject = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBufferObject);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(robotJson.indices), gl.STATIC_DRAW);
                
                // Color
                const colorBufferObject = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, colorBufferObject);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Float32Array(robotJson.vertices), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(program.aVertexColor);
                gl.vertexAttribPointer(program.aVertexColor, 3, gl.FLOAT, false, 0, 0);

                // Set values to be able to draw later
                robotJson.vao = vao;
                robotJson.ibo = indexBufferObject;

                //push the matrices into robot array
                robot.push(robotJson);
                console.log(robot);

                // Clean
                gl.bindVertexArray(null);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
            }
            )
        }

        function draw() {
            gl.clearColor(...clearColor, 1);
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

            // Update of which shader is currently activated
            gl.uniform1i(program.uShaderSelection, shaderSelection);

            // Update of material parameters, mainly affecting diffuse and specular
            gl.uniform3f(program.uMaterialDiffuse, materialDiffuse, materialDiffuse, materialDiffuse);
            gl.uniform3f(program.uMaterialSpecular, materialSpecular, materialSpecular, materialSpecular);

            // Update of light parameters, mainly affecting Phong, Lambert and Gouraud
            gl.uniform3f(program.uLightDiffuse, lightDiffuse, lightDiffuse, lightDiffuse);
            gl.uniform3f(program.uLightSpecular, lightSpecular, lightSpecular, lightSpecular);
            gl.uniform3f(program.uLightAmbient, lightAmbient, lightAmbient, lightAmbient);
            gl.uniform1f(program.uShininess, shininess);

            // Update of Cook-Torrance parameters
            gl.uniform1f(program.uRoughness, roughness);
            gl.uniform1f(program.uDiffuse, diffuse);
            gl.uniform1f(program.uReflectance, reflectance);

            // Update of Ward parameters
            gl.uniform1f(program.uDiffuseWard, diffuseWard);
            gl.uniform1f(program.uLobeMagnitude, lobe);
            gl.uniform1f(program.uAlphaX, alphaX);
            gl.uniform1f(program.uAlphaY, alphaY);

            // Light coordinates
            gl.uniform3fv(program.uLightPosition, lightPosition);

            // Camera coordinates
            mat4.perspective(projectionMatrix, 45, gl.canvas.width / gl.canvas.height, 1, 5000);
            mat4.identity(modelViewMatrix);
            mat4.translate(modelViewMatrix, modelViewMatrix, transformPosition);
            mat4.rotate(modelViewMatrix, modelViewMatrix, transformRotate[0], [1, 0, 0]);
            mat4.rotate(modelViewMatrix, modelViewMatrix, transformRotate[1], [0, 1, 0]);
            mat4.rotate(modelViewMatrix, modelViewMatrix, transformRotate[2], [0, 0, 1]);

            mat4.copy(normalMatrix, modelViewMatrix);
            mat4.invert(normalMatrix, normalMatrix);
            mat4.transpose(normalMatrix, normalMatrix);

            gl.uniformMatrix4fv(program.uProjectionMatrix, false, projectionMatrix);
            gl.uniformMatrix4fv(program.uModelViewMatrix, false, modelViewMatrix);
            gl.uniformMatrix4fv(program.uNormalMatrix, false, normalMatrix);

            // Bind
            gl.bindVertexArray(robot[0].vao);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, robot[0].ibo);

            // Draw
            gl.drawElements(gl.TRIANGLES, robot[0].indices.length, gl.UNSIGNED_SHORT, 0);

            // Clean
            gl.bindVertexArray(null);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        }

        function init() {
            initProgram();
            initLights();
            initControls();
            load();
            render();

        }

        window.onload = init;
    </script>

</head>

<body>
    <canvas id="webgl-canvas" width="1024" height="768">
        This web browser doesn't support HTML5 canvas.
    </canvas>
</body>

</html>