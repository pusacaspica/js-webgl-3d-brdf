<html>

    <head>
        <title>Trabalho 2 -- Alternative BDSF</title>

        <!-- libraries -->
        <!--link rel="stylesheet" href="/common/lib/normalize.css"-->
        <script type="text/javascript" src="/common/lib/gl-matrix.js"></script>
        <script type="text/javascript" src="/common/lib/dat.gui.js"></script>
        
        <!-- modules -->
        <script type="text/javascript" src="/common/js/utils.js"></script>
        <script type="text/javascript" src="/common/js/Program.js"></script>


        <script type="text/javascript">
            'use strict';

            //Global variables
            let
                gl,
                program,
                angle = 0,
                robot = [],
                before = 0,
                shininess = 24,
                distance = -1750,
                height_distance = -125,
                normalMatrix = mat4.create(),
                clearColor = [0.2, 0.2, 0.35],
                lightPosition = [100, 400, 100],
                modelViewMatrix = mat4.create(),
                projectionMatrix = mat4.create(),
                robotJson;
            
            async function getShader(type, path){
                let shaderSource;
                
                await fetch(path).then(
                    resp => resp.text()
                ).then(
                    (result)=>{
                        shaderSource = result;
                    }
                ).catch(err=>console.log(err));

                let shader;
                if(type === 'vertex'){
                    shader = gl.createShader(gl.VERTEX_SHADER);
                } else if (type === 'fragment'){
                    shader = gl.createShader(gl.FRAGMENT_SHADER);
                } else {
                    return null;
                }

                gl.shaderSource(shader, shaderSource);
                gl.compileShader(shader);

                if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)){
                    console.error(gl.getShaderInfoLog(shader));
                    return null;
                }

                return shader;
            }

            async function getModel(path){
                let model;

                await fetch(path).then(
                    resp=>resp.json()
                ).then(
                    (result)=>{
                        model = result;
                    }
                )

                return model;
            }

            // Global variables to use throughout application
            async function initProgram(){
                const canvas = document.getElementById('webgl-canvas');

                gl = canvas.getContext('webgl2') || console.error('WebGL2 is not available in your browser.');
                gl.clearColor(...clearColor, 1);
                gl.enable(gl.DEPTH_TEST);
                gl.depthFunc(gl.LEQUAL);

                program = gl.createProgram();

                let vertexShader = await getShader('vertex', 'robot_vertex.sh');
                let fragShader = await getShader('fragment', 'robot_frag.sh');
                
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragShader);
                gl.linkProgram(program);

                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    return console.error('Could not initialize shaders.');
                }

                // Attributes to be loaded into program
                const attributes = [
                    'aVertexPosition',
                    'aVertexNormal'
                ];

                // Uniforms to be loaded into program
                const uniforms = [
                    'uProjectionMatrix',
                    'uModelViewMatrix',
                    'uNormalMatrix',
                    'uLightAmbient',
                    'uLightPosition',
                    'uMaterialSpecular',
                    'uMaterialDiffuse',
                    'uShininess'
                ];

                gl.useProgram(program);

                attributes.forEach(attribute =>{
                    program.attribute = gl.getAttribLocation(program, attribute);
                })

                uniforms.forEach(uniform => {
                    program.uniform = gl.getUniformLocation(program, uniform);
                })

                robotJson = await getModel('Robot_tpose.json');
            }

            function initLights(){
                gl.uniform3fv(program.uLightPosition, lightPosition);
                gl.uniform3f(program.uLightAmbient, 0.1, 0.1, 0.1);
                gl.uniform3f(program.uMaterialSpecular, 0.5, 0.5, 0.5);
                gl.uniform3f(program.uMaterialDiffuse, 0.8, 0.8, 0.8);
                gl.uniform1f(program.uShininess, shininess);
            }

            function initControls(){

            }

            function animate(){
                const now = new Date().getTime();
                if(before){
                    const elapsed = now - before;
                    angle += (90 * elapsed) / 1000;
                }
                before = now;
            }

            function render(){
                requestAnimationFrame(render);
                draw();
                animate();
            }

            function load(){

                // Configure VAO
                const vao = gl.createVertexArray();
                gl.bindVertexArray(vao);

                // Vertices
                const vertexBufferObject = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBufferObject);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(robotJson.vertices), gl.STATIC_DRAW);
                // Configure instructions for VAO
                gl.enableVertexAttribArray(program.aVertexPosition);
                gl.vertexAttribPointer(program.aVertexPosition, 3, gl.FLOAT, false, 0, 0);

                // Normals
                const normalBufferObject = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, normalBufferObject);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(robotJson.normals), gl.STATIC_DRAW);
                // Configure instructions for VAO
                gl.enableVertexAttribArray(program.aVertexNormal);
                gl.vertexAttribPointer(program.aVertexNormal, 3, gl.FLOAT, false, 0, 0);
                        
                // Indices
                const indexBufferObject = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBufferObject);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(robotJson.indices), gl.STATIC_DRAW);
                        
                // Set values to be able to draw later
                robotJson.vao = vao;
                robotJson.ibo = indexBufferObject;

                // Push onto `parts` array for later access
                robot.push(robotJson);

                // Clean
                gl.bindVertexArray(null);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
            }

            function draw(){
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

                // We will discuss these operations in later chapters
                mat4.perspective(projectionMatrix, 45, gl.canvas.width / gl.canvas.height, 1, 100000);
                mat4.identity(modelViewMatrix);
                mat4.translate(modelViewMatrix, modelViewMatrix, [0, 0, distance]);
                mat4.translate(modelViewMatrix, modelViewMatrix, [0, height_distance, 0]);
                mat4.rotate(modelViewMatrix, modelViewMatrix, 30 * Math.PI / 180, [1, 0, 0]);
                mat4.rotate(modelViewMatrix, modelViewMatrix, angle * Math.PI / 180, [0, 1, 0]);

                mat4.copy(normalMatrix, modelViewMatrix);
                mat4.invert(normalMatrix, normalMatrix);
                mat4.transpose(normalMatrix, normalMatrix);

                gl.uniformMatrix4fv(program.uProjectionMatrix, false, projectionMatrix);
                gl.uniformMatrix4fv(program.uModelViewMatrix, false, modelViewMatrix);
                gl.uniformMatrix4fv(program.uNormalMatrix, false, normalMatrix);

                // Bind
                gl.bindVertexArray(robot[0].vao);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, robot[0].ibo);

                // Draw
                gl.drawElements(gl.TRIANGLES, robot[0].indices.length, gl.UNSIGNED_SHORT, 0);

                // Clean
                gl.bindVertexArray(null);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
            }

            function init(){
                initProgram().then( () => {
                        initLights();
                        load();
                        render();

                        //initControls();
                    }
                )
            }

            window.onload = init;
        </script>

    </head>

    <body>
        <canvas id="webgl-canvas" width="1024" height="768">
            This web browser doesn't support HTML5 canvas.
        </canvas>
    </body>

</html>